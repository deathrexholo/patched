/**
 * Organization Connection Service
 * Manages peer-to-peer connection requests between:
 * - Organizations and Athletes (org_to_athlete)
 * - Coaches and Organizations (coach_to_org)
 *
 * No admin approval required - recipients accept/reject directly
 */

import { db } from '../../lib/firebase';
import {
  collection,
  query,
  where,
  getDocs,
  doc,
  getDoc,
  addDoc,
  updateDoc,
  deleteDoc,
  Timestamp,
  QueryConstraint,
  orderBy,
  limit,
  startAfter,
} from 'firebase/firestore';
import {
  OrganizationConnection,
  ConnectionActivity,
  SendConnectionRequestData,
  AcceptConnectionRequestData,
  RejectConnectionRequestData,
  ConnectionType,
  ConnectionStatus,
  ConnectionStats,
  ConnectionTimeline,
  ConnectionFilter,
} from '../../types/models/organizationConnection';
import notificationService from '../notificationService';

const CONNECTIONS_COLLECTION = 'organizationConnections';
const ACTIVITY_COLLECTION = 'connectionActivity';

class OrganizationConnectionService {
  /**
   * Send a peer-to-peer connection request
   * Supports both org→athlete and coach→org connections
   */
  async sendConnectionRequest(
    data: SendConnectionRequestData
  ): Promise<OrganizationConnection> {
    try {
      // Check if request already exists
      const existingRequest = await this.checkConnectionExists(
        data.senderId,
        data.recipientId,
        data.connectionType
      );

      if (existingRequest) {
        throw new Error('Connection request already exists between these users');
      }

      // Create new connection request
      const connectionData = {
        connectionType: data.connectionType,
        senderId: data.senderId,
        senderName: data.senderName,
        senderPhotoURL: data.senderPhotoURL,
        senderRole: data.senderRole,
        recipientId: data.recipientId,
        recipientName: data.recipientName,
        recipientPhotoURL: data.recipientPhotoURL,
        recipientRole: data.recipientRole,
        status: 'pending' as ConnectionStatus,
        createdAt: Timestamp.now(),
        createdViaConnection: true,
      };

      const docRef = await addDoc(collection(db, CONNECTIONS_COLLECTION), connectionData);

      // Log activity
      await this.logConnectionActivity({
        connectionId: docRef.id,
        connectionType: data.connectionType,
        action: 'request_sent',
        performedByUserId: data.senderId,
        performedByName: data.senderName,
        senderId: data.senderId,
        senderName: data.senderName,
        recipientId: data.recipientId,
        recipientName: data.recipientName,
      });return {

      // Send notification to recipient
      try {
        await notificationService.sendConnectionRequestNotification(
          data.recipientId,
          data.senderName,
          data.senderRole,
          data.senderPhotoURL,
          data.connectionType
        );
      } catch (notificationError) {
        console.error('Failed to send connection request notification:', notificationError);
        // Don't throw - connection was created successfully
      }

        id: docRef.id,
        ...connectionData,
      } as OrganizationConnection;
    } catch (error) {
      console.error('❌ Error sending connection request:', error);
      throw error;
    }
  }

  /**
   * Check if a connection request already exists between two users
   */
  async checkConnectionExists(
    senderId: string,
    recipientId: string,
    connectionType: ConnectionType
  ): Promise<OrganizationConnection | null> {
    try {
      const q = query(
        collection(db, CONNECTIONS_COLLECTION),
        where('senderId', '==', senderId),
        where('recipientId', '==', recipientId),
        where('connectionType', '==', connectionType),
        where('status', '!=', 'rejected')
      );

      const querySnapshot = await getDocs(q);

      if (querySnapshot.empty) {
        return null;
      }

      const doc = querySnapshot.docs[0];
      return {
        id: doc.id,
        ...doc.data(),
      } as OrganizationConnection;
    } catch (error) {
      console.error('❌ Error checking connection existence:', error);
      throw error;
    }
  }

  /**
   * Get all pending connection requests for a user (as recipient)
   */
  async getPendingRequestsForUser(
    userId: string,
    connectionType?: ConnectionType
  ): Promise<OrganizationConnection[]> {
    try {
      const constraints: QueryConstraint[] = [
        where('recipientId', '==', userId),
        where('status', '==', 'pending'),
      ];

      if (connectionType) {
        constraints.push(where('connectionType', '==', connectionType));
      }

      const q = query(
        collection(db, CONNECTIONS_COLLECTION),
        ...constraints,
        orderBy('createdAt', 'desc')
      );

      const querySnapshot = await getDocs(q);
      const requests = querySnapshot.docs.map(
        (doc) =>
          ({
            id: doc.id,
            ...doc.data(),
          } as OrganizationConnection)
      );return requests;
    } catch (error) {
      console.error('❌ Error getting pending requests:', error);
      throw error;
    }
  }

  /**
   * Get all accepted connections for a user
   */
  async getAcceptedConnectionsForUser(
    userId: string,
    connectionType?: ConnectionType
  ): Promise<OrganizationConnection[]> {
    try {
      const constraints: QueryConstraint[] = [
        where('recipientId', '==', userId),
        where('status', '==', 'accepted'),
      ];

      if (connectionType) {
        constraints.push(where('connectionType', '==', connectionType));
      }

      const q = query(
        collection(db, CONNECTIONS_COLLECTION),
        ...constraints,
        orderBy('acceptedAt', 'desc')
      );

      const querySnapshot = await getDocs(q);
      const connections = querySnapshot.docs.map(
        (doc) =>
          ({
            id: doc.id,
            ...doc.data(),
          } as OrganizationConnection)
      );

      return connections;
    } catch (error) {
      console.error('❌ Error getting accepted connections:', error);
      throw error;
    }
  }

  /**
   * Get single connection request by ID
   */
  async getConnectionRequest(connectionId: string): Promise<OrganizationConnection | null> {
    try {
      const docRef = doc(db, CONNECTIONS_COLLECTION, connectionId);
      const docSnapshot = await getDoc(docRef);

      if (!docSnapshot.exists()) {
        console.warn('⚠️ Connection request not found:', connectionId);
        return null;
      }

      return {
        id: docSnapshot.id,
        ...docSnapshot.data(),
      } as OrganizationConnection;
    } catch (error) {
      console.error('❌ Error getting connection request:', error);
      throw error;
    }
  }

  /**
   * Accept a connection request (peer-to-peer)
   * Recipient accepts and friendship is created
   */
  async acceptConnectionRequest(data: AcceptConnectionRequestData): Promise<OrganizationConnection> {
    try {
      // Get the connection request
      const connection = await this.getConnectionRequest(data.connectionId);
      if (!connection) {
        throw new Error('Connection request not found');
      }

      // Update connection status
      const connectionRef = doc(db, CONNECTIONS_COLLECTION, data.connectionId);
      const acceptedAt = Timestamp.now();

      await updateDoc(connectionRef, {
        status: 'accepted',
        acceptedAt,
      });

      // Create friendship document
      const friendshipRef = await addDoc(collection(db, 'friendships'), {
        requesterId: connection.senderId,
        requesterName: connection.senderName,
        requesterPhotoURL: connection.senderPhotoURL,
        recipientId: connection.recipientId,
        recipientName: connection.recipientName,
        recipientPhotoURL: connection.recipientPhotoURL,
        status: 'accepted',
        createdAt: acceptedAt,
        connectionId: data.connectionId,
        createdViaConnection: connection.connectionType,
      });

      // Update connection with friendship ID
      await updateDoc(connectionRef, {
        friendshipId: friendshipRef.id,
      });

      // Log activity
      await this.logConnectionActivity({
        connectionId: data.connectionId,
        connectionType: connection.connectionType,
        action: 'request_accepted',
        performedByUserId: data.acceptedByUserId,
        performedByName: data.acceptedByName,
        senderId: connection.senderId,
        senderName: connection.senderName,
        recipientId: connection.recipientId,
        recipientName: connection.recipientName,
      });return {
        id: data.connectionId,
        ...connection,
        status: 'accepted',
        acceptedAt,
        friendshipId: friendshipRef.id,
      };
    } catch (error) {
      console.error('❌ Error accepting connection request:', error);
      throw error;
    }
  }

  /**
   * Reject a connection request
   */
  async rejectConnectionRequest(
    data: RejectConnectionRequestData
  ): Promise<OrganizationConnection> {
    try {
      // Get the connection request
      const connection = await this.getConnectionRequest(data.connectionId);
      if (!connection) {
        throw new Error('Connection request not found');
      }

      // Update connection status
      const connectionRef = doc(db, CONNECTIONS_COLLECTION, data.connectionId);
      const rejectedAt = Timestamp.now();

      await updateDoc(connectionRef, {
        status: 'rejected',
        rejectedAt,
        rejectionReason: data.reason,
      });

      // Log activity
      await this.logConnectionActivity({
        connectionId: data.connectionId,
        connectionType: connection.connectionType,
        action: 'request_rejected',
        performedByUserId: data.rejectedByUserId,
        performedByName: data.rejectedByName,
        senderId: connection.senderId,
        senderName: connection.senderName,
        recipientId: connection.recipientId,
        recipientName: connection.recipientName,
        metadata: { reason: data.reason },
      });return {
        id: data.connectionId,
        ...connection,
        status: 'rejected',
        rejectedAt,
      };
    } catch (error) {
      console.error('❌ Error rejecting connection request:', error);
      throw error;
    }
  }

  /**
   * Cancel a pending connection request (sender can withdraw)
   */
  async cancelConnectionRequest(
    connectionId: string,
    cancelledByUserId: string
  ): Promise<void> {
    try {
      const connection = await this.getConnectionRequest(connectionId);

      if (!connection) {
        throw new Error('Connection request not found');
      }

      if (connection.status !== 'pending') {
        throw new Error('Can only cancel pending connection requests');
      }

      if (connection.senderId !== cancelledByUserId) {
        throw new Error('Only the sender can cancel a connection request');
      }

      // Delete the connection request
      const connectionRef = doc(db, CONNECTIONS_COLLECTION, connectionId);
      await deleteDoc(connectionRef);

      // Log activity
      await this.logConnectionActivity({
        connectionId,
        connectionType: connection.connectionType,
        action: 'request_cancelled',
        performedByUserId: cancelledByUserId,
        performedByName: connection.senderName,
        senderId: connection.senderId,
        senderName: connection.senderName,
        recipientId: connection.recipientId,
        recipientName: connection.recipientName,
      });} catch (error) {
      console.error('❌ Error cancelling connection request:', error);
      throw error;
    }
  }

  /**
   * Log connection activity for audit trail and admin dashboard
   */
  async logConnectionActivity(
    activity: Omit<ConnectionActivity, 'id' | 'actionDate'>
  ): Promise<void> {
    try {
      await addDoc(collection(db, ACTIVITY_COLLECTION), {
        ...activity,
        actionDate: Timestamp.now(),
      });} catch (error) {
      console.error('❌ Error logging activity:', error);
      throw error;
    }
  }

  /**
   * Get connection activity history for admin dashboard
   */
  async getConnectionActivityHistory(filters?: {
    connectionType?: ConnectionType;
    limit?: number;
  }): Promise<ConnectionActivity[]> {
    try {
      const constraints: QueryConstraint[] = [];

      if (filters?.connectionType) {
        constraints.push(where('connectionType', '==', filters.connectionType));
      }

      constraints.push(orderBy('actionDate', 'desc'));
      constraints.push(limit(filters?.limit || 50));

      const q = query(collection(db, ACTIVITY_COLLECTION), ...constraints);
      const querySnapshot = await getDocs(q);

      return querySnapshot.docs.map(
        (doc) =>
          ({
            id: doc.id,
            ...doc.data(),
          } as ConnectionActivity)
      );
    } catch (error) {
      console.error('❌ Error getting activity history:', error);
      throw error;
    }
  }

  /**
   * Get connection statistics for admin dashboard
   */
  async getConnectionStats(): Promise<ConnectionStats> {
    try {
      // Get counts for each status
      const statsPromises = [
        this.getCountByStatus('pending'),
        this.getCountByStatus('accepted'),
        this.getCountByStatus('rejected'),
      ];

      const [pendingCount, acceptedCount, rejectedCount] = await Promise.all(statsPromises);

      const total = pendingCount + acceptedCount + rejectedCount;
      const acceptanceRate = total > 0 ? (acceptedCount / total) * 100 : 0;

      // Get average days to accept
      const avgDaysToAccept = await this.calculateAverageDaysToAccept();

      return {
        totalPending: pendingCount,
        totalAccepted: acceptedCount,
        totalRejected: rejectedCount,
        acceptanceRate: Math.round(acceptanceRate * 100) / 100,
        averageDaysToAccept: avgDaysToAccept,
      };
    } catch (error) {
      console.error('❌ Error getting connection stats:', error);
      throw error;
    }
  }

  /**
   * Get timeline data for connection analytics
   */
  async getConnectionTimeline(days: number = 30): Promise<ConnectionTimeline[]> {
    try {
      const now = new Date();
      const startDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);

      const activities = await this.getConnectionActivityHistory({ limit: 1000 });

      // Group by date
      const timelineMap = new Map<string, ConnectionTimeline>();

      activities.forEach((activity) => {
        const date = new Date(activity.actionDate as any);
        if (date >= startDate) {
          const dateStr = date.toISOString().split('T')[0];

          if (!timelineMap.has(dateStr)) {
            timelineMap.set(dateStr, {
              date: dateStr,
              newRequests: 0,
              accepted: 0,
              rejected: 0,
            });
          }

          const timeline = timelineMap.get(dateStr)!;
          if (activity.action === 'request_sent') timeline.newRequests++;
          else if (activity.action === 'request_accepted') timeline.accepted++;
          else if (activity.action === 'request_rejected') timeline.rejected++;
        }
      });

      return Array.from(timelineMap.values()).sort((a, b) =>
        a.date.localeCompare(b.date)
      );
    } catch (error) {
      console.error('❌ Error getting timeline:', error);
      throw error;
    }
  }

  // ============ Helper Methods ============

  private async getCountByStatus(status: ConnectionStatus): Promise<number> {
    const q = query(
      collection(db, CONNECTIONS_COLLECTION),
      where('status', '==', status)
    );
    const snapshot = await getDocs(q);
    return snapshot.size;
  }

  private async calculateAverageDaysToAccept(): Promise<number> {
    try {
      const q = query(
        collection(db, CONNECTIONS_COLLECTION),
        where('status', '==', 'accepted')
      );
      const snapshot = await getDocs(q);

      if (snapshot.empty) return 0;

      let totalDays = 0;
      let count = 0;

      snapshot.docs.forEach((doc) => {
        const data = doc.data();
        if (data.createdAt && data.acceptedAt) {
          const createdTime = (data.createdAt as Timestamp).toMillis();
          const acceptedTime = (data.acceptedAt as Timestamp).toMillis();
          const days = (acceptedTime - createdTime) / (1000 * 60 * 60 * 24);
          totalDays += days;
          count++;
        }
      });

      return count > 0 ? Math.round(totalDays / count * 10) / 10 : 0;
    } catch (error) {
      console.error('❌ Error calculating average days:', error);
      return 0;
    }
  }

  private async getTopSendersByRole(
    senderRole: 'organization' | 'coach',
    connectionType: ConnectionType,
    limit: number
  ): Promise<
    Array<{
      organizationId?: string;
      organizationName?: string;
      coachId?: string;
      coachName?: string;
      totalRequests: number;
      accepted: number;
      pending: number;
      acceptanceRate: number;
    }>
  > {
    try {
      const q = query(
        collection(db, CONNECTIONS_COLLECTION),
        where('senderRole', '==', senderRole),
        where('connectionType', '==', connectionType)
      );

      const snapshot = await getDocs(q);
      const senderMap = new Map<
        string,
        { name: string; totalRequests: number; accepted: number; pending: number }
      >();

      snapshot.docs.forEach((doc) => {
        const data = doc.data();
        const senderId = data.senderId;
        const senderName = data.senderName;

        if (!senderMap.has(senderId)) {
          senderMap.set(senderId, {
            name: senderName,
            totalRequests: 0,
            accepted: 0,
            pending: 0,
          });
        }

        const sender = senderMap.get(senderId)!;
        sender.totalRequests++;
        if (data.status === 'accepted') sender.accepted++;
        if (data.status === 'pending') sender.pending++;
      });

      return Array.from(senderMap.entries())
        .map(([senderId, data]) => ({
          ...(senderRole === 'organization'
            ? { organizationId: senderId, organizationName: data.name }
            : { coachId: senderId, coachName: data.name }),
          totalRequests: data.totalRequests,
          accepted: data.accepted,
          pending: data.pending,
          acceptanceRate:
            data.totalRequests > 0
              ? Math.round((data.accepted / data.totalRequests) * 100 * 100) / 100
              : 0,
        }))
        .sort((a, b) => b.totalRequests - a.totalRequests)
        .slice(0, limit);
    } catch (error) {
      console.error('❌ Error getting top senders:', error);
      return [];
    }
  }

  private async getTopRecipients(
    connectionType: ConnectionType,
    limit: number
  ): Promise<
    Array<{
      athleteId: string;
      athleteName: string;
      totalRequests: number;
      accepted: number;
      pending: number;
      acceptanceRate: number;
    }>
  > {
    try {
      const q = query(
        collection(db, CONNECTIONS_COLLECTION),
        where('connectionType', '==', connectionType)
      );

      const snapshot = await getDocs(q);
      const recipientMap = new Map<
        string,
        { name: string; totalRequests: number; accepted: number; pending: number }
      >();

      snapshot.docs.forEach((doc) => {
        const data = doc.data();
        const recipientId = data.recipientId;
        const recipientName = data.recipientName;

        if (!recipientMap.has(recipientId)) {
          recipientMap.set(recipientId, {
            name: recipientName,
            totalRequests: 0,
            accepted: 0,
            pending: 0,
          });
        }

        const recipient = recipientMap.get(recipientId)!;
        recipient.totalRequests++;
        if (data.status === 'accepted') recipient.accepted++;
        if (data.status === 'pending') recipient.pending++;
      });

      return Array.from(recipientMap.entries())
        .map(([recipientId, data]) => ({
          athleteId: recipientId,
          athleteName: data.name,
          totalRequests: data.totalRequests,
          accepted: data.accepted,
          pending: data.pending,
          acceptanceRate:
            data.totalRequests > 0
              ? Math.round((data.accepted / data.totalRequests) * 100 * 100) / 100
              : 0,
        }))
        .sort((a, b) => b.totalRequests - a.totalRequests)
        .slice(0, limit);
    } catch (error) {
      console.error('❌ Error getting top recipients:', error);
      return [];
    }
  }

  /**
   * Get all incoming pending requests for a user (convenience alias)
   */
  async getIncomingPendingRequests(recipientId: string): Promise<OrganizationConnection[]> {
    return this.getPendingRequestsForUser(recipientId);
  }

  /**
   * Get all accepted connections for a user (convenience alias)
   */
  async getAcceptedConnections(recipientId: string): Promise<OrganizationConnection[]> {
    return this.getAcceptedConnectionsForUser(recipientId);
  }

  /**
   * Get connection status between two users (checks both directions)
   * Returns 'pending', 'accepted', 'none', or 'rejected'
   */
  async getConnectionStatusBetweenUsers(
    userId1: string,
    userId2: string
  ): Promise<'pending' | 'accepted' | 'rejected' | 'none'> {
    try {
      // Check if userId1 sent a request to userId2
      const q1 = query(
        collection(db, CONNECTIONS_COLLECTION),
        where('senderId', '==', userId1),
        where('recipientId', '==', userId2),
        where('status', 'in', ['pending', 'accepted', 'rejected'])
      );

      const snapshot1 = await getDocs(q1);

      if (!snapshot1.empty) {
        const status = snapshot1.docs[0].data().status as ConnectionStatus;
        return status;
      }

      // Check if userId2 sent a request to userId1
      const q2 = query(
        collection(db, CONNECTIONS_COLLECTION),
        where('senderId', '==', userId2),
        where('recipientId', '==', userId1),
        where('status', 'in', ['pending', 'accepted', 'rejected'])
      );

      const snapshot2 = await getDocs(q2);

      if (!snapshot2.empty) {
        const status = snapshot2.docs[0].data().status as ConnectionStatus;
        return status;
      }

      return 'none';
    } catch (error) {
      console.error('❌ Error getting connection status between users:', error);
      return 'none';
    }
  }
}

export const organizationConnectionService = new OrganizationConnectionService();
